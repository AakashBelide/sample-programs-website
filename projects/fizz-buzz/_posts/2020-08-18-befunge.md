---
title: Fizz Buzz in Befunge
layout: default
last-modified: 2020-08-18
featured-image:
tags: [befunge, fizz-buzz]
authors:
  - stuin
---

Here we will go over Fizz Buzz in Befunge.

## How to Implement the Solution

Befunge, like many other esoteric languages, has a very unique look to is, and tends to seem very complex at first glance. Each operation is denoted by a single character, and the file can be traversed in four directions. If you have not read about it before, do that first, starting here: [The Befunge Programming Language][1].

```
1 >  :3%   v
   v  \0   _ "zziF",,,,v
   v  \1               <
   > :5%   v
   v _v#\  _ "zzuB",,,,v
   v  >:.  v $\        <
   v       <       @
   > :25* ::, *1-` |
  ^        +1      <
```

The problem itself is here:

    If a number is divisible by 3, print the word ‘Fizz’ instead of the number.
    If the number is divisible by 5, print the word ‘Buzz’ instead of the number.
    Finally, if the number is divisible by both 3 and 5, print ‘FizzBuzz’ instead
    of the number. Otherwise, just print the number.

Don't worry, we can break it down and go over the different sections now.

### First set

The first section to look at will handle the Fizz statement, and add a binary value to the output for later.

```
1 >  :3%   v
   v  \0   _ "zziF",,,,v
   v  \1               <
```

The program will start at the top left corner, meaning that the stack will start with a 1, and then cross over the top line, running the characters `:3%`.

- `:` will make a copy of the top char, this time being a 1,
- `3` will push a 3 on top of the stack.
- `%` will run modulus on the top two chars, returning the remainder of x / 3.

Moving down onto the `_` char, it will run as an if statement, moving right if the top or the stack is 0, and left if it is anything else. Combined with the previous statements, it will move right whenever the initial value is divisible by 3, pushing `zziF` to the stack and printing it out reversed.

Finally, the instruction pointer returns to the left, adding either a 1 to the stack after printing Fizz, or a 0 if nothing was printed. The `\` then swaps the top two values, putting this indicator behind the current run count.

### Second set

The second section of code is very simaler, intended to handle the Buzz part of the program.

```
   > :5%   v
   v _v#\  _ "zzuB",,,,v
   v  >:.  v $\        <
   v       <
```

Like the previous section, `:5%` will calculate the remainder of x / 5, and the `_` will send the pointer left or right accordingly.

- If the value is divisible, the program will print out `Buzz` and head to the downward arrow at the center, `\$` deleting the 0 or 1 value that was stored earlier.
- If the current iteration is not divisible, `\` will switch that number with the binary value stored in the first set, and `#` will jump straight to the `_` statement at the start of the middle line. This effectivly checks if anything has been printed at all, and if the current line is blank, prints out the current numerical value with `:.`.

### Cleanup

The final section handles the new line and tests for end of program, or sets up the pointer for the next loop.

```
   v               @
   > :25* ::, *1-` |
  ^        +1      <
```

The middle line has three main statements, `:25*` copies the current value, and then pushes 2 * 5 to the stack. `::,` makes 2 more copies of 10, before printing out the top one as an enter. Finally, `*1-'` multiplies the 10s together, subtracts 1 from it to get 99, and checks if the current iteration number is larger, pushing 1 if so.

At the end, `|` checks for a zero on top of the stack, and sends the pointer downward if it is there. If there is a `1`, signalling that the current iteration is 100, the `@` symbol is run, ending the program.

If it has not yet reached 100, `1+` adds to the current top value, and the pointer is sent back to the top of the program to start again.

## How to run the solution

Because of the particular design of the language, your best option is a Befunge interpreter. This is both for availability and because watching it run is the only way to really understand (or debug) it.

- [Befunge Playground][2]
- [jsFunge IDE][3]
- [Befunge-93 Interpreter][4]

There are compilers as well, even through the technical challenges:

- [Tim’s Befunge Compiler][5]
- [BefunUtils][6]

For a much more thorough look at Befunge, it’s list of operators, and its various derivatives, I recommend the [Esolang Wiki][7].

## Further Reading

- [Hello World in Befunge][1] on The Renegade Coder

[1]: https://sample-programs.therenegadecoder.com/languages/befunge/
[2]: https://www.bedroomlan.org/tools/befunge-playground/#prog=hello,mode=edit
[3]: https://befunge.flogisoft.com/
[4]: http://www.quirkster.com/iano/js/befunge.html
[5]: https://quadium.net/funge/tbc/
[6]: https://www.mikescher.de/programs/view/BefunUtils
[7]: https://esolangs.org/wiki/Befunge