---
title: Fizz Buzz in Befunge
layout: default
last-modified: 2020-08-19
featured-image:
tags: [befunge, fizz-buzz]
authors:
  - stuin
---

Here we will go over Fizz Buzz in Befunge.

## How to Implement the Solution

Befunge, like many other esoteric languages, has a very unique look to is, and tends to seem very complex at first glance. Each operation is denoted by a single character, and the file can be traversed in four directions. If you have not read about it before, do that first, starting here: [The Befunge Programming Language][1].

```
1 >  :3%   v
   v  \0   _ "zziF",,,,v
   v  \1               <
   > :5%   v
   v _v#\  _ "zzuB",,,,v
   v  >:.  v $\        <
   v       <       @
   > :25* ::, *1-` |
  ^        +1      <
```

The problem itself is here:

    If a number is divisible by 3, print the word ‘Fizz’ instead of the number.
    If the number is divisible by 5, print the word ‘Buzz’ instead of the number.
    Finally, if the number is divisible by both 3 and 5, print ‘FizzBuzz’ instead
    of the number. Otherwise, just print the number.

Don't worry, we can break it down and go over the different sections now.

### First set

The first section to look at will handle the Fizz statement, and add a binary value to the output for later.

```
1 >  :3%   v
   v  \0   _ "zziF",,,,v
   v  \1               <
```

The program will start at the top left corner, meaning that the stack will start with a 1, and then cross over the top line, running the characters `:3%`.

- `:` will make a copy of the top char, this time being a 1,
- `3` will push a 3 on top of the stack.
- `%` will run modulus on the top two chars, returning the remainder of x / 3.

Moving down onto the `_` char, it will run as an if statement, moving right if the top or the stack is 0, and left if it is anything else. Combined with the previous statements, it will move right whenever the initial value is divisible by 3, pushing `zziF` to the stack and printing it out in the proper order.

Finally, the instruction pointer returns to the left, adding either a 1 to the stack after printing Fizz, or a 0 if nothing was printed. The `\` then swaps the top two values, putting this indicator below the current run count.

### Second set

The second section of code is very simaler, intended to handle the Buzz part of the program.

```
   > :5%   v
   v _v#\  _ "zzuB",,,,v
   v  >:.  v $\        <
   v       <
```

Like the previous section, `:5%` will calculate the remainder of x / 5, and the `_` will send the pointer left or right accordingly.

- If the value is divisible, the program will print out `Buzz` and head to the downward arrow at the center, `\$` deleting the 0 or 1 value that was stored earlier.
- If the current iteration is not divisible, `\` will switch that number with the binary value stored in the first set, and `#` will jump straight to the `_` statement at the start of the second line. This effectivly checks if anything has been printed at all, and if the current line is blank, prints out the current numerical value with `:.`.

### Cleanup

The final section handles the new line and eigther ends the program, or sets up the pointer for the next loop.

```
   v               @
   > :25* ::, *1-` |
  ^        +1      <
```

The middle line has three main statements, `:25*` copies the current value, and then pushes 2 * 5 to the stack. `::,` makes 2 more copies of 10, before printing out one of them as an enter. Finally, `*1-'` multiplies the 10s together, subtracts 1 from it to get 99, and checks if the current iteration number is larger, pushing 1 if so.

At the end, `|` checks for a zero on top of the stack, sending the pointer downward if one is found. If there is a 1, signalling that the current iteration is 100, the `@` symbol is run instead, ending the program.

If the counter has not yet reached 100, `1+` adds to that particular value, and the pointer is sent back to the top of the program for the next loop.

## How to run the solution

Because of the particular design of the language, your best option is a Befunge interpreter. It is a lot easier to learn and play around with when you can step through and see what the pointer is doing.

- [Befunge Playground][2]
- [jsFunge IDE][3]
- [Befunge-93 Interpreter][4]

You could also try one of these compilers:

- [Tim’s Befunge Compiler][5]
- [BefunUtils][6]

For more information on Befunge, check the [Esolang Wiki][7].

## Further Reading

[1]: https://sample-programs.therenegadecoder.com/languages/befunge/
[2]: https://www.bedroomlan.org/tools/befunge-playground/#prog=hello,mode=edit
[3]: https://befunge.flogisoft.com/
[4]: http://www.quirkster.com/iano/js/befunge.html
[5]: https://quadium.net/funge/tbc/
[6]: https://www.mikescher.de/programs/view/BefunUtils
[7]: https://esolangs.org/wiki/Befunge